/* Generated By:JJTree&JavaCC: Do not edit this line. OutputJS.java */
package com.js2pv.too;

import java.awt.BorderLayout;
import java.awt.Container;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.WindowConstants;

public class OutputJS extends JFrame/*@bgen(jjtree)*/implements OutputJSTreeConstants, OutputJSConstants {/*@bgen(jjtree)*/
  protected static JJTOutputJSState jjtree = new JJTOutputJSState();public OutputJS(){
        Container c=getContentPane();
    c.setLayout(new BorderLayout(5,5));
    JPanel jp1=new JPanel();
    JTextArea jt=new JTextArea(50,50);
    JScrollPane js=new JScrollPane(jt);
    jp1.setLayout(new GridLayout(2,2,5,5));
    JButton bt1=new JButton("\u5bfc\u5165\u6587\u4ef6");
    JButton bt2=new JButton("\u751f\u6210PV\u8bed\u8a00");
    JButton bt3=new JButton("\u751f\u6210pv\u8bed\u8a00\u8bed\u6cd5\u6811");
    JButton bt4=new JButton("\u751f\u6210\u6587\u4ef6");
    jp1.add(bt1);
    jp1.add(bt2);
    jp1.add(bt3);
    jp1.add(bt4);
    c.add(jp1,BorderLayout.NORTH);
    c.add(js,BorderLayout.CENTER);
        setTitle("borderLayout");
    setSize(400,400);
    setVisible(true);
    setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        bt2.addActionListener(new ActionListener() {
                @Override
            public void actionPerformed(ActionEvent e) {
                        // TODO Auto-generated method stub
                        try {
                        bt2dostr();
                        }catch(IOException e1) {
                                e1.printStackTrace();
                                }}
        public void bt2dostr() throws IOException {
                        jt.setText(" ");
                        File file=new File("F:\u005c\u005ceclipse\u005c\u005ceclipse\u005c\u005ceclipse-workspace\u005c\u005cJs2PvProje\u005c\u005csrc\u005c\u005ccom\u005c\u005cjs2pv\u005c\u005ctoo\u005c\u005coutput2.txt");
                        try {
                                FileReader fr=new FileReader(file);
                                BufferedReader bis=new BufferedReader(fr);
                                char[] c=new char[50];
                                int len;
                                while((len=bis.read(c))!=-1) {
                                        String str=new String(c,0,len);
                                        jt.setText(str);
                                }
                                fr.close();
                        } catch (FileNotFoundException e1) {
                                // TODO Auto-generated catch block
                                e1.printStackTrace();
                        } catch (IOException e1) {
                                // TODO Auto-generated catch block
                                e1.printStackTrace();
                        }
                }
        });
    bt1.addActionListener(new ActionListener () {
                @Override
                public void actionPerformed(ActionEvent e) {
                        // TODO Auto-generated method stub
            bt1getstr();
            }
        public void bt1getstr() {
                        // TODO Auto-generated method stub    	
                File file=new File("\u005c\u005ceclipse\u005c\u005ceclipse\u005c\u005ceclipse-workspace\u005c\u005cJs2PvProje\u005c\u005csrc\u005c\u005ccom\u005c\u005cjs2pv\u005c\u005ctoo\u005c\u005coutput1.txt");
                        try {
                                FileReader fr=new FileReader(file);
                                BufferedReader bis=new BufferedReader(fr);
                                char[] c=new char[50];
                                int len;
                                while((len=bis.read(c))!=-1) {
                                        String str=new String(c,0,len);
                                        jt.setText(str);
                                }
                                fr.close();
                        } catch (FileNotFoundException e1) {
                                // TODO Auto-generated catch block
                                e1.printStackTrace();
                        } catch (IOException e1) {
                                // TODO Auto-generated catch block
                                e1.printStackTrace();
                        }
                }
        });
  }
public InputStream openfile() {
        File file=new File("\u005c\u005ceclipse\u005c\u005ceclipse\u005c\u005ceclipse-workspace\u005c\u005cJs2PvProje\u005c\u005csrc\u005c\u005ccom\u005c\u005cjs2pv\u005c\u005ctoo\u005c\u005coutput1.txt");
                try {
                        FileReader fr=new FileReader(file);
                        BufferedReader bis=new BufferedReader(fr);
                        char[] c=new char[50];
                        int len;
                        while((len=bis.read(c))!=-1) {
                                String str=new String(c,0,len);
                                InputStream incode=new ByteArrayInputStream(str.getBytes());
                                return incode;
                        }
                        fr.close();
                } catch (FileNotFoundException e1) {
                        // TODO Auto-generated catch block
                        e1.printStackTrace();
                } catch (IOException e1) {
                        // TODO Auto-generated catch block
                        e1.printStackTrace();
                }
                return null;
        }

  public static void main(String args[]) {
          new OutputJS(new OutputJS().openfile());
    try {
      SimpleNode n = OutputJS.Start();
      StringBuffer s=new StringBuffer("the input is:");
      String str=n.jjtAccept(new OutputVisitor(),s).toString();
         File file=new File("\u005c\u005ceclipse\u005c\u005ceclipse\u005c\u005ceclipse-workspace\u005c\u005cJs2PvProje\u005c\u005csrc\u005c\u005ccom\u005c\u005cjs2pv\u005c\u005ctoo\u005c\u005coutput2.txt");
         FileWriter fw =new FileWriter(file);
         BufferedWriter bw=new BufferedWriter(fw);
       bw.write(str);
       bw.flush();
       bw.close();
      System.out.println("Thank you.");
   }catch (Exception e) {
      System.out.println("Oops.");
      System.out.println(e.getMessage());
    }
    }

  static final public SimpleNode Start() throws ParseException {
                    /*@bgen(jjtree) Start */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      process();
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return jjtn000;}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void process() throws ParseException {
                 /*@bgen(jjtree) process */
  SimpleNode jjtn000 = new SimpleNode(JJTPROCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VAR:
        varsub();
        newdefine();
        definemaohao();
        break;
      case ident:
      case DIGIT:
        expstub();
        break;
      case FUNCTION:
        definefunction();
        newdefine();
        defineLP();
        newdefine();
        defineRP();
        defineOBRACE();
        funblock();
        defineCBARCE();
        break;
      case IF:
        defineeif();
        jj_consume_token(LP);
        expstub();
        jj_consume_token(RP);
        expstub();
        defineeelse();
        expstub();
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       {if (true) throw (RuntimeException)jjte000;}
     }
     if (jjte000 instanceof ParseException) {
       {if (true) throw (ParseException)jjte000;}
     }
     {if (true) throw (Error)jjte000;}
    } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
    }
  }

  static final public void exp() throws ParseException {
             /*@bgen(jjtree) exp */
  SimpleNode jjtn000 = new SimpleNode(JJTEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      expstub();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        defineeelor();
        break;
      case AND:
        defineand();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      expstub();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void funblock() throws ParseException {
                   /*@bgen(jjtree) funblock */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      newobject();
      usefun();
      newsend();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void newobject() throws ParseException {
                    /*@bgen(jjtree) newobject */
  SimpleNode jjtn000 = new SimpleNode(JJTNEWOBJECT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      varsub();
      newdefine();
      definedengyu();
      defineNEW();
      newdefine();
      defineLP();
      defineRP();
      definemaohao();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void usefun() throws ParseException {
                  /*@bgen(jjtree) usefun */
  SimpleNode jjtn000 = new SimpleNode(JJTUSEFUN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      nomeat();
      yinword();
      defineCOMMA();
      yinwordpoint();
      defineRP();
      definemaohao();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void newsend() throws ParseException {
                   /*@bgen(jjtree) newsend */
  SimpleNode jjtn000 = new SimpleNode(JJTNEWSEND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      newdefine();
      definepoint();
      newdefine();
      defineLP();
      newdefine();
      defineRP();
      definemaohao();
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  static final public void nomeat() throws ParseException {
                /*@bgen(jjtree) nomeat */
  SimpleNode jjtn000 = new SimpleNode(JJTNOMEAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      newdefine();
      definepoint();
      newdefine();
      defineLP();
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void yinword() throws ParseException {
                  /*@bgen(jjtree) yinword */
  SimpleNode jjtn000 = new SimpleNode(JJTYINWORD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      defineyinhao();
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ident:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_1;
        }
        newdefine();
      }
      defineyinhao();
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  static final public void yinwordpoint() throws ParseException {
                      /*@bgen(jjtree) yinwordpoint */
  SimpleNode jjtn000 = new SimpleNode(JJTYINWORDPOINT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      defineyinhao();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ident:
          ;
          break;
        default:
          jj_la1[3] = jj_gen;
          break label_2;
        }
        newdefine();
      }
      definepoint();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ident:
          ;
          break;
        default:
          jj_la1[4] = jj_gen;
          break label_3;
        }
        newdefine();
      }
      defineyinhao();
    } catch (Throwable jjte000) {
  if (jjtc000) {
    jjtree.clearNodeScope(jjtn000);
    jjtc000 = false;
  } else {
    jjtree.popNode();
  }
  if (jjte000 instanceof RuntimeException) {
    {if (true) throw (RuntimeException)jjte000;}
  }
  if (jjte000 instanceof ParseException) {
    {if (true) throw (ParseException)jjte000;}
  }
  {if (true) throw (Error)jjte000;}
    } finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
    }
  }

  static final public void expstub() throws ParseException {
                /*@bgen(jjtree) expstub */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPSTUB);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
        digitsub();
        break;
      case ident:
        newdefine();
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQU:
        definedengyu();
        break;
      case NOTEQ:
        definenotequal();
        break;
      case EQ:
        defineequal();
        break;
      case BIGEQ:
        definebigger();
        break;
      case SMALLEQ:
        definesmaller();
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
        digitsub();
        break;
      case ident:
        newdefine();
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
        definemaohao();
        break;
      default:
        jj_la1[8] = jj_gen;
        ;
      }
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
  }

  static final public String digitsub() throws ParseException {
 /*@bgen(jjtree) digitsub */
  SimpleNode jjtn000 = new SimpleNode(JJTDIGITSUB);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(DIGIT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    {if (true) return token.image;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  static final public void varsub() throws ParseException {
 /*@bgen(jjtree) varsub */
  SimpleNode jjtn000 = new SimpleNode(JJTVARSUB);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(VAR);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void newdefine() throws ParseException {
 /*@bgen(jjtree) newdefine */
SimpleNode jjtn000 = new SimpleNode(JJTNEWDEFINE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(ident);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void newdefinelet() throws ParseException {
 /*@bgen(jjtree) newdefinelet */
SimpleNode jjtn000 = new SimpleNode(JJTNEWDEFINELET);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(LET);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void newdefinein() throws ParseException {
 /*@bgen(jjtree) newdefinein */
SimpleNode jjtn000 = new SimpleNode(JJTNEWDEFINEIN);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(IN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineeif() throws ParseException {
 /*@bgen(jjtree) defineeif */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEEIF);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(IF);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void definemaohao() throws ParseException {
 /*@bgen(jjtree) definemaohao */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEMAOHAO);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(SEMICOLON);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineethen() throws ParseException {
 /*@bgen(jjtree) defineethen */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEETHEN);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(THEN);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineeelse() throws ParseException {
 /*@bgen(jjtree) defineeelse */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEEELSE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(ELSE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineeelor() throws ParseException {
 /*@bgen(jjtree) defineeelor */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEEELOR);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(OR);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineand() throws ParseException {
 /*@bgen(jjtree) defineand */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEAND);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(AND);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void definefunction() throws ParseException {
 /*@bgen(jjtree) definefunction */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEFUNCTION);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(FUNCTION);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void definedengyu() throws ParseException {
 /*@bgen(jjtree) definedengyu */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEDENGYU);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(EQU);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineequal() throws ParseException {
 /*@bgen(jjtree) defineequal */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEEQUAL);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(EQ);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void definenull() throws ParseException {
 /*@bgen(jjtree) definenull */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINENULL);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(NULL);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void definenotequal() throws ParseException {
 /*@bgen(jjtree) definenotequal */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINENOTEQUAL);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(NOTEQ);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void definebigger() throws ParseException {
 /*@bgen(jjtree) definebigger */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEBIGGER);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(BIGEQ);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void definesmaller() throws ParseException {
 /*@bgen(jjtree) definesmaller */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINESMALLER);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(SMALLEQ);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineOBRACE() throws ParseException {
 /*@bgen(jjtree) defineOBRACE */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEOBRACE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(OBRACE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineCBARCE() throws ParseException {
 /*@bgen(jjtree) defineCBARCE */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINECBARCE);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(CBARCE);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineNEW() throws ParseException {
 /*@bgen(jjtree) defineNEW */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINENEW);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(New);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineyinhao() throws ParseException {
 /*@bgen(jjtree) defineyinhao */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEYINHAO);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(YINHAO);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void definepoint() throws ParseException {
 /*@bgen(jjtree) definepoint */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINEPOINT);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(POINT);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineLP() throws ParseException {
 /*@bgen(jjtree) defineLP */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINELP);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(LP);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineRP() throws ParseException {
 /*@bgen(jjtree) defineRP */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINERP);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(RP);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static final public void defineCOMMA() throws ParseException {
 /*@bgen(jjtree) defineCOMMA */
SimpleNode jjtn000 = new SimpleNode(JJTDEFINECOMMA);
boolean jjtc000 = true;
jjtree.openNodeScope(jjtn000);Token token;
    try {
      token = jj_consume_token(COMMA);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtn000.jjtSetValue(token.image);
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public OutputJSTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[9];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x5009200,0x0,0x1000000,0x1000000,0x1000000,0x5000000,0x80000000,0x5000000,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x300,0x0,0x0,0x0,0x0,0x1058,0x0,0x1,};
   }

  /** Constructor with InputStream. */
  public OutputJS(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public OutputJS(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new OutputJSTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public OutputJS(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new OutputJSTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public OutputJS(OutputJSTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(OutputJSTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 9; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[52];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 9; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 52; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
